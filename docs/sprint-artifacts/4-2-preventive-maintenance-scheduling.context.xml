<?xml version="1.0" encoding="UTF-8"?>
<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>2</storyId>
    <title>Preventive Maintenance Scheduling</title>
    <status>drafted</status>
    <generatedAt>2025-11-24</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-2-preventive-maintenance-scheduling.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>property manager</asA>
    <iWant>to set up recurring preventive maintenance schedules</iWant>
    <soThat>equipment is maintained proactively and failures are prevented</soThat>
    <tasks>
      <!-- Task 1: Define TypeScript Types, Enums, and Schemas (AC: #20) -->
      <task id="1" ac="20">
        <description>Define TypeScript Types, Enums, and Schemas</description>
        <subtasks>
          <subtask>Create types/pm-schedule.ts with PMSchedule, CreatePMScheduleRequest, UpdatePMScheduleRequest, PMScheduleStatistics interfaces</subtask>
          <subtask>Define enums: RecurrenceType, PMScheduleStatus</subtask>
          <subtask>Create lib/validations/pm-schedule.ts with createPMScheduleSchema, updatePMScheduleSchema (Zod)</subtask>
          <subtask>Create services/pm-schedule.service.ts with API methods</subtask>
          <subtask>Export types from types/index.ts</subtask>
        </subtasks>
      </task>

      <!-- Task 2: Implement Backend PMSchedule Entity and Repository (AC: #6, #18) -->
      <task id="2" ac="6,18">
        <description>Implement Backend PMSchedule Entity and Repository</description>
        <subtasks>
          <subtask>Create PMSchedule entity with all fields (id, scheduleName, propertyId, category, description, recurrenceType, dates, priority, assignee, status, timestamps)</subtask>
          <subtask>Create PMScheduleRepository extending JpaRepository</subtask>
          <subtask>Add database migration for pm_schedules table (Flyway)</subtask>
          <subtask>Add indexes on propertyId, status, nextGenerationDate, category</subtask>
          <subtask>Add pmScheduleId FK field to WorkOrder entity (link work orders to PM schedules)</subtask>
        </subtasks>
      </task>

      <!-- Task 3-19: Additional tasks as defined in story -->
      <!-- See source story file for complete task list -->
    </tasks>
  </story>

  <acceptanceCriteria>
    <!-- AC1: PM Schedule Creation Form Route and Structure -->
    <criterion id="AC1" priority="high">
      <title>PM Schedule Creation Form Route and Structure</title>
      <description>PM schedule creation accessible at /property-manager/pm-schedules/new for users with PROPERTY_MANAGER or MAINTENANCE_SUPERVISOR roles. Uses Next.js App Router within (dashboard) route group. Form page is client component with React Hook Form state management. Form sections: Schedule Information (name, property, category, description), Recurrence Settings (type, start/end dates), Assignment (default priority, default assignee). Implements responsive layout: single column full-width on mobile, two-column layout on desktop. Skeleton loader shown while property dropdown loads. Page requires authentication middleware - redirect to /login if not authenticated. Breadcrumb navigation: Dashboard > PM Schedules > Create New.</description>
      <source>docs/epics/epic-4-maintenance-operations.md#story-42-preventive-maintenance-scheduling, docs/architecture.md#frontend-implementation-patterns</source>
    </criterion>

    <!-- AC2-AC22: Additional acceptance criteria -->
    <!-- See source story file for complete AC list -->
    
    <criterion id="AC12" priority="critical">
      <title>Automated Work Order Generation (Scheduled Job)</title>
      <description>Implement Spring @Scheduled job that runs daily at 2:00 AM UAE time (cron: "0 0 2 * * ?"). Job logic: query all PMSchedule entities where status = ACTIVE and nextGenerationDate <= today. For each matching schedule: create WorkOrder entity with type = PREVENTIVE, link to PM schedule (pmScheduleId FK), set title = "{scheduleName} - {property name or 'All Properties'}", copy description from PM schedule, set category from PM schedule, set priority = defaultPriority, set scheduledDate = nextGenerationDate, assign to defaultAssigneeId if specified (otherwise leave unassigned), set status = OPEN (or ASSIGNED if assignee specified), generate work order number (WO-2025-XXXX). Update PM schedule: set lastGeneratedDate = today, calculate and set nextGenerationDate based on recurrenceType (MONTHLY: +1 month, QUARTERLY: +3 months, SEMI_ANNUALLY: +6 months, ANNUALLY: +1 year), if endDate exists and nextGenerationDate > endDate, set status = COMPLETED. Send email notification to assigned person (if specified) with work order details. Log generation in audit_logs: action "PM_WORK_ORDER_GENERATED".</description>
      <source>docs/epics/epic-4-maintenance-operations.md#automated-work-order-generation, docs/architecture.md#scheduled-jobs</source>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- PRD Section: Preventive Maintenance -->
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>3.4.2 Preventive Maintenance (PM)</section>
        <snippet>Property managers can set up recurring PM schedules (monthly, quarterly, semi-annually, annually) for equipment maintenance. System automatically generates work orders based on schedules.</snippet>
      </doc>

      <!-- Epic 4: Maintenance Operations -->
      <doc>
        <path>docs/epics/epic-4-maintenance-operations.md</path>
        <title>Epic 4: Maintenance Operations</title>
        <section>Story 4.2: Preventive Maintenance Scheduling</section>
        <snippet>Complete story definition including PM schedule creation form, automated work order generation, recurrence types (MONTHLY, QUARTERLY, SEMI_ANNUALLY, ANNUALLY), and scheduled job running daily at 2 AM.</snippet>
      </doc>

      <!-- Architecture: Scheduled Jobs -->
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Async Processing - Spring @Scheduled</section>
        <snippet>Use Spring @Async and @Scheduled for async processing. PMScheduler runs daily at 8 AM to check PM schedules and generate work orders. Sufficient for monolith, ThreadPoolTaskExecutor.</snippet>
      </doc>

      <!-- Architecture: Frontend Implementation Patterns -->
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Frontend Implementation Patterns</section>
        <snippet>Next.js App Router with (dashboard) route groups, React Hook Form + Zod validation, shadcn/ui components, server-side pagination with @tanstack/react-table.</snippet>
      </doc>

      <!-- Architecture: Form Pattern -->
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Form Pattern with React Hook Form + Zod</section>
        <snippet>Use zodResolver for schema validation, inline error display, character counters for textareas, focus first error field on submit.</snippet>
      </doc>

      <!-- Architecture: Date and Time Handling -->
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Date and Time Handling</section>
        <snippet>Storage: UTC timezone in database. API: ISO 8601 format. Display: Convert to user's timezone (UAE/GST) in frontend. Use Java 17 java.time (LocalDateTime, ZonedDateTime) and date-fns for frontend.</snippet>
      </doc>

      <!-- UX Design Specification -->
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>UX Design Specification</title>
        <section>8.2 WCAG Compliance</section>
        <snippet>Color contrast ratio ≥ 4.5:1, keyboard navigation, ARIA labels, screen reader support, focus indicators on all interactive elements.</snippet>
      </doc>

      <!-- Story 4.1: Work Order Creation (Prerequisite) -->
      <doc>
        <path>docs/sprint-artifacts/4-1-work-order-creation-and-management.md</path>
        <title>Story 4.1: Work Order Creation and Management</title>
        <section>Dev Notes - Learnings</section>
        <snippet>Reusable patterns: StatusBadge, PriorityBadge, CategoryIcon components. Data table with server-side pagination. React Hook Form + Zod validation. Axios + React Query for API integration.</snippet>
      </doc>
    </docs>

    <code>
      <!-- Existing WorkOrder Entity -->
      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/WorkOrder.java</path>
        <kind>entity</kind>
        <symbol>WorkOrder</symbol>
        <lines>38-288</lines>
        <reason>PM schedules will generate WorkOrder entities. Need to add pmScheduleId FK field to link work orders to PM schedules. WorkOrder already has category, priority, status, scheduledDate fields that will be populated from PM schedule.</reason>
      </artifact>

      <!-- WorkOrder Enums -->
      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/enums/WorkOrderCategory.java</path>
        <kind>enum</kind>
        <symbol>WorkOrderCategory</symbol>
        <reason>PM schedule uses same categories (PLUMBING, ELECTRICAL, HVAC, etc.) for filtering vendors and work order generation.</reason>
      </artifact>

      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/enums/WorkOrderPriority.java</path>
        <kind>enum</kind>
        <symbol>WorkOrderPriority</symbol>
        <reason>PM schedule has defaultPriority field that maps to WorkOrderPriority (HIGH, MEDIUM, LOW) for generated work orders.</reason>
      </artifact>

      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/enums/WorkOrderStatus.java</path>
        <kind>enum</kind>
        <symbol>WorkOrderStatus</symbol>
        <reason>Generated work orders start with OPEN status (or ASSIGNED if default assignee specified).</reason>
      </artifact>

      <!-- WorkOrder Service -->
      <artifact>
        <path>backend/src/main/java/com/ultrabms/service/WorkOrderService.java</path>
        <kind>service</kind>
        <symbol>WorkOrderService</symbol>
        <reason>PM schedule generation will call WorkOrderService to create work orders programmatically. May need to add method for PM-generated work orders.</reason>
      </artifact>

      <!-- Frontend Work Order Types -->
      <artifact>
        <path>frontend/src/types/work-orders.ts</path>
        <kind>types</kind>
        <symbol>WorkOrder types</symbol>
        <reason>PM schedule will reference work order types for generated work orders history display.</reason>
      </artifact>

      <!-- Frontend Work Order Service -->
      <artifact>
        <path>frontend/src/services/work-orders.service.ts</path>
        <kind>service</kind>
        <symbol>Work Orders API service</symbol>
        <reason>May need to query work orders filtered by pmScheduleId for history tracking.</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="react-hook-form" version="^7.0.0">Form state management</package>
        <package name="zod" version="^3.0.0">Schema validation</package>
        <package name="@hookform/resolvers" version="^3.0.0">Zod resolver for React Hook Form</package>
        <package name="@tanstack/react-query" version="^5.0.0">Server state management, caching</package>
        <package name="@tanstack/react-table" version="^8.11.0">Data table with server-side pagination</package>
        <package name="date-fns" version="^3.0.0">Date manipulation and formatting</package>
        <package name="lucide-react" version="^0.263.1">Icons for categories and UI</package>
      </node>
      <java>
        <package name="spring-boot-starter-web" version="3.4.7">REST API</package>
        <package name="spring-boot-starter-data-jpa" version="3.4.7">Database access</package>
        <package name="spring-boot-starter-validation" version="3.4.7">Bean validation</package>
        <package name="spring-boot-starter-mail" version="3.4.7">Email notifications</package>
        <package name="postgresql" version="17.6">Database driver</package>
        <package name="flyway-core" version="latest">Database migrations</package>
        <package name="lombok" version="latest">Reduce boilerplate</package>
      </java>
      <shadcn>
        <component>form</component>
        <component>input</component>
        <component>textarea</component>
        <component>select</component>
        <component>calendar</component>
        <component>radio-group</component>
        <component>button</component>
        <component>card</component>
        <component>dialog</component>
        <component>alert-dialog</component>
        <component>badge</component>
        <component>breadcrumb</component>
        <component>table</component>
        <component>pagination</component>
        <component>skeleton</component>
        <component>toast</component>
        <component>alert</component>
      </shadcn>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- Development Constraints from Dev Notes and Architecture -->
    <constraint type="pattern">
      <name>Spring @Scheduled Pattern</name>
      <description>Use Spring @Scheduled annotation with cron expression "0 0 2 * * ?" for daily execution at 2:00 AM UAE time. Use @Async for non-blocking execution. Implement job monitoring and logging.</description>
      <source>docs/architecture.md#async-processing</source>
    </constraint>

    <constraint type="pattern">
      <name>Date Calculation Pattern</name>
      <description>Use Java LocalDate for date arithmetic. Handle month-end edge cases (e.g., Jan 31 + 1 month = Feb 28/29). Store dates in UTC, display in UAE timezone (GST). Use date-fns for frontend date formatting.</description>
      <source>docs/sprint-artifacts/4-2-preventive-maintenance-scheduling.md#dev-notes</source>
    </constraint>

    <constraint type="pattern">
      <name>Data Table Pattern</name>
      <description>Reuse server-side data table implementation from Story 4.1. Use @tanstack/react-table for server-side pagination, sorting, filtering. Persist filter state in URL query params. Column visibility toggle, row selection. Mobile: convert to card view (stacked rows).</description>
      <source>docs/sprint-artifacts/4-1-work-order-creation-and-management.md</source>
    </constraint>

    <constraint type="pattern">
      <name>Form Validation Pattern</name>
      <description>React Hook Form + Zod. Inline validation errors. Character counters for textareas. Focus first error field on submit. Use zodResolver for schema validation.</description>
      <source>docs/architecture.md#form-pattern-with-react-hook-form-zod</source>
    </constraint>

    <constraint type="testing">
      <name>Testing Standards</name>
      <description>ALL interactive elements MUST have data-testid attributes following convention {component}-{element}-{action}. Mandatory for buttons, inputs, selects, textareas, table rows, dialogs. Verified in code review before PR approval. Achieve ≥ 80% code coverage for new code.</description>
      <source>docs/sprint-artifacts/4-2-preventive-maintenance-scheduling.md#dev-notes</source>
    </constraint>

    <constraint type="accessibility">
      <name>WCAG Compliance</name>
      <description>Color contrast ratio ≥ 4.5:1 for all text. Keyboard navigation (Tab, Enter, Escape, Arrow keys). ARIA labels (role="form", role="table", aria-label on icon buttons, aria-describedby for hints, aria-live="polite" for updates, aria-busy="true" during loading). Screen reader announcements for status updates. Focus indicators visible on all interactive elements.</description>
      <source>docs/ux-design-specification.md#8.2-wcag-compliance</source>
    </constraint>

    <constraint type="edit-restriction">
      <name>PM Schedule Edit Restrictions</name>
      <description>Can edit: scheduleName, description, category, defaultPriority, defaultAssigneeId, endDate. Cannot edit: propertyId (locked after creation), recurrenceType (locked), startDate (locked). Can only edit if status = ACTIVE or PAUSED.</description>
      <source>docs/sprint-artifacts/4-2-preventive-maintenance-scheduling.md#dev-notes</source>
    </constraint>

    <constraint type="delete-restriction">
      <name>PM Schedule Delete Restrictions</name>
      <description>Can only delete if no work orders have been generated yet. If work orders exist, must complete schedule instead of deleting. Deletion is soft delete (status = DELETED).</description>
      <source>docs/sprint-artifacts/4-2-preventive-maintenance-scheduling.md#dev-notes</source>
    </constraint>

    <constraint type="responsive-design">
      <name>Responsive Design Requirements</name>
      <description>Mobile (&lt;640px): single column layout, full-width form fields, stack cards vertically, table switches to card view, touch targets ≥ 44×44px. Tablet (640px-1024px): 2-column layout for form. Desktop (&gt;1024px): centered container max-width 1200px for form, full-width data table. Dark theme support using shadcn dark mode classes.</description>
      <source>docs/architecture.md#responsive-design</source>
    </constraint>
  </constraints>

  <interfaces>
    <!-- Backend API Endpoints -->
    <interface>
      <name>POST /api/v1/pm-schedules</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/pm-schedules
Request: {scheduleName, propertyId, category, description, recurrenceType, startDate, endDate, defaultPriority, defaultAssigneeId}
Response: {success: true, data: {id, scheduleName, status, nextGenerationDate, createdAt}}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>GET /api/v1/pm-schedules</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/v1/pm-schedules?status=ACTIVE&amp;property=uuid&amp;category=HVAC&amp;frequency=QUARTERLY&amp;search=HVAC&amp;page=0&amp;size=20&amp;sort=nextGenerationDate,ASC
Response: {pmSchedules: [], totalPages, totalElements}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>GET /api/v1/pm-schedules/{id}</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/v1/pm-schedules/{id}
Response: {id, scheduleName, propertyId, propertyName, category, description, recurrenceType, startDate, endDate, defaultPriority, defaultAssigneeId, defaultAssigneeName, status, nextGenerationDate, lastGeneratedDate, createdAt, updatedAt, statistics: {totalGenerated, completedCount, overdueCount, avgCompletionDays}}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>PUT /api/v1/pm-schedules/{id}</name>
      <kind>REST endpoint</kind>
      <signature>PUT /api/v1/pm-schedules/{id}
Request: {scheduleName, description, category, defaultPriority, defaultAssigneeId, endDate}
Response: {success: true, data: {updated PM schedule}}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>PATCH /api/v1/pm-schedules/{id}/status</name>
      <kind>REST endpoint</kind>
      <signature>PATCH /api/v1/pm-schedules/{id}/status
Request: {status: "ACTIVE" | "PAUSED" | "COMPLETED"}
Response: {success: true, data: {id, status}}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>POST /api/v1/pm-schedules/{id}/generate-now</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/pm-schedules/{id}/generate-now
Response: {success: true, data: {workOrderId, workOrderNumber}}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>GET /api/v1/pm-schedules/{id}/history</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/v1/pm-schedules/{id}/history?page=0&amp;size=10
Response: {workOrders: [], totalPages, totalElements}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <interface>
      <name>DELETE /api/v1/pm-schedules/{id}</name>
      <kind>REST endpoint</kind>
      <signature>DELETE /api/v1/pm-schedules/{id}
Response: {success: true, message: "PM schedule deleted"}</signature>
      <path>backend/src/main/java/com/ultrabms/controller/PMScheduleController.java</path>
    </interface>

    <!-- Reusable Components from Story 4.1 -->
    <interface>
      <name>StatusBadge Component</name>
      <kind>React component</kind>
      <signature>StatusBadge({ status: PMScheduleStatus }): JSX.Element
Color-coded status badges (ACTIVE=green, PAUSED=yellow, COMPLETED=gray)</signature>
      <path>frontend/src/components/work-orders/StatusBadge.tsx</path>
    </interface>

    <interface>
      <name>PriorityBadge Component</name>
      <kind>React component</kind>
      <signature>PriorityBadge({ priority: WorkOrderPriority }): JSX.Element
Color-coded priority badges (HIGH=red, MEDIUM=yellow, LOW=blue)</signature>
      <path>frontend/src/components/work-orders/PriorityBadge.tsx</path>
    </interface>

    <interface>
      <name>CategoryIcon Component</name>
      <kind>React component</kind>
      <signature>CategoryIcon({ category: WorkOrderCategory }): JSX.Element
lucide-react icons for categories (Droplet, Zap, Wind, etc.)</signature>
      <path>frontend/src/components/work-orders/CategoryIcon.tsx</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing standards from Story 4.1 and architecture: Use JUnit 5 + Mockito for backend unit tests. Use Vitest + React Testing Library for frontend component tests. Use Playwright for E2E tests. All interactive elements must have data-testid attributes following convention {component}-{element}-{action}. Achieve ≥ 80% code coverage. Test role-based access control, form validation, scheduled job execution, date calculations for all recurrence types.
    </standards>

    <locations>
      <location>backend/src/test/java/com/ultrabms/service/PMScheduleServiceTest.java</location>
      <location>backend/src/test/java/com/ultrabms/controller/PMScheduleControllerTest.java</location>
      <location>backend/src/test/java/com/ultrabms/scheduler/PMScheduleGenerationJobTest.java</location>
      <location>frontend/src/components/pm-schedules/__tests__/PMScheduleForm.test.tsx</location>
      <location>frontend/src/components/pm-schedules/__tests__/PMScheduleList.test.tsx</location>
      <location>frontend/src/components/pm-schedules/__tests__/PMScheduleDetails.test.tsx</location>
      <location>frontend/e2e/pm-schedules.spec.ts</location>
    </locations>

    <ideas>
      <!-- Test ideas mapped to acceptance criteria -->
      <idea ac="AC1">
        <description>Test PM schedule creation form route and authentication</description>
        <tests>
          <test>Verify route /property-manager/pm-schedules/new is accessible for PROPERTY_MANAGER role</test>
          <test>Verify route redirects to /login if not authenticated</test>
          <test>Verify breadcrumb navigation displays correctly</test>
          <test>Verify skeleton loader shown while property dropdown loads</test>
        </tests>
      </idea>

      <idea ac="AC5">
        <description>Test form validation and submission</description>
        <tests>
          <test>Submit form without scheduleName → verify required field error</test>
          <test>Submit form without description → verify required field error (min 20 chars)</test>
          <test>Submit form with description &gt; 1000 chars → verify max length error</test>
          <test>Submit form with endDate &lt; startDate → verify validation error</test>
          <test>Submit valid form → verify work order created and success toast shown</test>
        </tests>
      </idea>

      <idea ac="AC12">
        <description>Test automated work order generation scheduled job</description>
        <tests>
          <test>Create PM schedule with nextGenerationDate = today → trigger job → verify work order generated</test>
          <test>Verify nextGenerationDate updated based on recurrence type (MONTHLY: +1 month, QUARTERLY: +3 months, etc.)</test>
          <test>Verify work order type = PREVENTIVE and linked to PM schedule</test>
          <test>Verify email notification sent to assigned person</test>
          <test>Verify audit log entry created with action "PM_WORK_ORDER_GENERATED"</test>
          <test>Verify schedule status = COMPLETED if endDate reached</test>
        </tests>
      </idea>

      <idea ac="AC13">
        <description>Test manual work order generation (Generate Now)</description>
        <tests>
          <test>Click "Generate Now" button → verify confirmation dialog shown</test>
          <test>Confirm generation → verify work order created immediately</test>
          <test>Verify nextGenerationDate NOT updated (manual generation is extra)</test>
          <test>Verify redirect to work order detail page</test>
        </tests>
      </idea>

      <idea ac="AC14">
        <description>Test pause/resume schedule flow</description>
        <tests>
          <test>Pause ACTIVE schedule → verify status = PAUSED and toast shown</test>
          <test>Resume PAUSED schedule → verify status = ACTIVE and toast shown</test>
          <test>Verify pause button only shown if status = ACTIVE</test>
          <test>Verify resume button only shown if status = PAUSED</test>
        </tests>
      </idea>

      <idea ac="AC22">
        <description>Test accessibility features</description>
        <tests>
          <test>Verify all interactive elements have data-testid attributes</test>
          <test>Test keyboard navigation (Tab, Enter, Escape)</test>
          <test>Verify ARIA labels on form fields and buttons</test>
          <test>Verify color contrast ratio ≥ 4.5:1</test>
          <test>Test with screen reader (VoiceOver/NVDA)</test>
        </tests>
      </idea>
    </ideas>
  </tests>
</story-context>
