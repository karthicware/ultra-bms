<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>User Registration and Login with JWT Authentication</title>
    <status>drafted</status>
    <generatedAt>2025-11-13</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-1-user-registration-and-login-with-jwt-authentication.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>to register an account and login securely</iWant>
    <soThat>I can access the application with my credentials using JWT authentication</soThat>
    <tasks>
      <task id="1">Create Authentication DTOs (RegisterRequest, LoginRequest, LoginResponse, RefreshTokenRequest, TokenResponse)</task>
      <task id="2">Create JWT Utility Class (JwtTokenProvider) with token generation, validation, and claim extraction</task>
      <task id="3">Create Token Blacklist Repository for logout functionality</task>
      <task id="4">Create AuthService for Registration and Login with password validation and rate limiting</task>
      <task id="5">Create AuthController with /register, /login, /refresh, /logout endpoints</task>
      <task id="6">Create Spring Security Configuration with JwtAuthenticationFilter</task>
      <task id="7">Create Audit Logging for Authentication Events</task>
      <task id="8">Implement Rate Limiting and Account Lockout (max 5 failed attempts per 15 minutes)</task>
      <task id="9">Add Password Strength Validation with @StrongPassword annotation</task>
      <task id="10">Configure JWT Secret and Properties in application-dev.yml</task>
      <task id="11">Test Authentication Flow End-to-End (registration, login, refresh, logout, rate limiting)</task>
      <task id="12">Update README and API Documentation</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="AC1">
      <description>User Registration API: POST /api/v1/auth/register accepts email (RFC 5322), password (min 8 chars with complexity), firstName, lastName, role, optional phone. Password hashed with BCrypt strength 12. Returns 201 Created with UserDto or 400/409 for validation/duplicate errors.</description>
    </ac>
    <ac id="AC2">
      <description>Password Validation: Enforce min 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character. Reject common passwords. Frontend displays password strength meter with real-time feedback. Never store plain text passwords.</description>
    </ac>
    <ac id="AC3">
      <description>User Login API: POST /api/v1/auth/login accepts email and password. Returns JWT access token (1 hour expiry), refresh token (7 days), token expiration, and user profile. Set HTTP-only cookie for refresh token. Returns 401 for invalid credentials.</description>
    </ac>
    <ac id="AC4">
      <description>JWT Implementation: Use Spring Security with JWT. HS256 algorithm for signing. Access token (1 hour) for API requests. Refresh token (7 days) for obtaining new access tokens. Refresh endpoint at POST /api/v1/auth/refresh. Tokens include: userId, email, role, iat, exp.</description>
    </ac>
    <ac id="AC5">
      <description>Security Measures: Rate limiting enforced (max 5 login attempts per 15 minutes per email). Account lockout for 30 minutes after 5 failed attempts. Log all authentication attempts with IP address and timestamp to audit_logs table.</description>
    </ac>
    <ac id="AC6">
      <description>Token Refresh Flow: POST /api/v1/auth/refresh validates refresh token (not expired, not revoked, active user). Returns new access token (1-hour expiry). Returns 401 if refresh token expired/invalid. Frontend auto-refreshes access token without user interaction.</description>
    </ac>
    <ac id="AC7">
      <description>Logout Implementation: POST /api/v1/auth/logout invalidates session by adding tokens to token_blacklist table with TTL. Clears HTTP-only refresh token cookie. Returns 204 No Content. Blacklisted tokens cannot be reused.</description>
    </ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>3.1.1 User Authentication</section>
        <snippet>Multi-factor authentication (MFA), Single Sign-On (SSO) support, Password recovery workflow (3-step process), Session management and timeout controls, Role-based access control (RBAC)</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>3.1.2 User Roles</section>
        <snippet>Six user roles defined: Super Admin (full system access), Property Manager (property-specific management), Maintenance Supervisor (work order and vendor management), Finance Manager (financial operations), Tenant (self-service portal), Vendor (job assignment tracking)</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Backend: Spring Boot 3 + Java 17</section>
        <snippet>Spring Boot 3.x framework with Spring Security, Spring Data JPA, PostgreSQL, Spring Validation, Spring Cache (Ehcache). Maven build system with Java 17 LTS.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Security & Authentication</section>
        <snippet>JWT-based stateless authentication with Spring Security 6+. BCrypt password hashing with strength 12. Access tokens (1 hour) and refresh tokens (7 days). Token blacklist for logout functionality.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epics Breakdown</title>
        <section>Epic 2: Story 2.1 - User Registration and Login</section>
        <snippet>Complete JWT authentication implementation with registration, login, token refresh, logout, rate limiting, account lockout, password strength validation, and audit logging. Prerequisites: Story 1.4 (User entity), Story 1.5 (REST API structure)</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>UX Design Specification</title>
        <section>Design System Foundation</section>
        <snippet>shadcn/ui with Tailwind CSS for UI components. TypeScript-first with Radix UI for WCAG 2.1 Level AA accessibility. Form components: form, label, input, textarea, date-picker. Feedback: toast, alert for validation errors.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/User.java</path>
        <kind>entity</kind>
        <symbol>User</symbol>
        <lines>1-82</lines>
        <reason>User entity already exists with passwordHash (BCrypt), email (unique indexed), firstName, lastName, role (UserRole enum), active, mfaEnabled fields. Extends BaseEntity for audit fields. Use for authentication and registration.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/repository/UserRepository.java</path>
        <kind>repository</kind>
        <symbol>UserRepository</symbol>
        <lines>17-44</lines>
        <reason>UserRepository provides findByEmail() method essential for login and registration duplicate check. Also provides findByRole() and findByActiveTrue() for user management.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/exception/GlobalExceptionHandler.java</path>
        <kind>exception-handler</kind>
        <symbol>GlobalExceptionHandler</symbol>
        <lines>1-323</lines>
        <reason>Global exception handler with @RestControllerAdvice already handles AuthenticationException → 401 and AccessDeniedException → 403. Extend with AccountLockedException → 423 Locked and InvalidTokenException → 401 Unauthorized.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/dto/UserDto.java</path>
        <kind>dto</kind>
        <symbol>UserDto</symbol>
        <lines>-</lines>
        <reason>UserDto record exists for user representation (excludes passwordHash). Reuse for registration response as per Story 1.5 pattern.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/config/CorsConfig.java</path>
        <kind>config</kind>
        <symbol>CorsConfig</symbol>
        <lines>52-85</lines>
        <reason>CorsConfig allows credentials (allowCredentials=true) which is required for HTTP-only refresh token cookies. Already configured for localhost:3000 frontend.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/filter/RequestCorrelationFilter.java</path>
        <kind>filter</kind>
        <symbol>RequestCorrelationFilter</symbol>
        <lines>-</lines>
        <reason>RequestCorrelationFilter provides X-Correlation-ID header for request tracing. Use correlation IDs in audit logging for authentication events.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/java/com/ultrabms/entity/BaseEntity.java</path>
        <kind>entity</kind>
        <symbol>BaseEntity</symbol>
        <lines>-</lines>
        <reason>BaseEntity provides UUID primary key, createdAt, updatedAt audit fields with @EntityListeners. All new entities (TokenBlacklist, AuditLog) should extend BaseEntity.</reason>
      </artifact>
      <artifact>
        <path>backend/src/main/resources/application-dev.yml</path>
        <kind>config</kind>
        <symbol>application-dev.yml</symbol>
        <lines>1-88</lines>
        <reason>Application config for development. Add JWT configuration: jwt.secret, jwt.access-token-expiration (3600000ms = 1 hour), jwt.refresh-token-expiration (604800000ms = 7 days). Flyway enabled for migrations.</reason>
      </artifact>
    </code>

    <dependencies>
      <backend>
        <framework name="Spring Boot" version="3.4.0" />
        <dependency name="Spring Security" version="included" note="For JWT authentication and method-level security" />
        <dependency name="Spring Data JPA" version="included" note="For repository and entity management" />
        <dependency name="PostgreSQL" version="runtime" note="Database driver" />
        <dependency name="Ehcache" version="3.10.8" note="Cache failed login attempts in LoginAttemptService" />
        <dependency name="Lombok" version="1.18.36" note="Reduce boilerplate with @Data, @RequiredArgsConstructor" />
        <dependency name="SpringDoc OpenAPI" version="2.8.4" note="For Swagger UI API documentation" />
        <dependency name="Flyway" version="included" note="For database migrations (V6-V8)" />
        <dependency name="jjwt (io.jsonwebtoken)" version="0.12.x" note="JWT library - NEEDS TO BE ADDED: jjwt-api, jjwt-impl, jjwt-jackson" />
        <dependency name="Passay" version="1.6.x" note="Password strength validation - NEEDS TO BE ADDED" />
      </backend>
      <frontend>
        <framework name="Next.js" version="16.0.2" />
        <dependency name="React" version="19.2.0" />
        <dependency name="React Hook Form" version="7.66.0" note="For registration and login forms" />
        <dependency name="Zod" version="4.1.12" note="For form validation schemas" />
        <dependency name="Axios" version="1.13.2" note="For API communication with interceptors for JWT" />
        <dependency name="shadcn/ui" note="UI component library - button, input, form, toast components" />
        <dependency name="Playwright" version="1.49.1" note="E2E testing framework" />
      </frontend>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Follow Story 1.5 pattern: Use constructor injection with @RequiredArgsConstructor for dependency injection</constraint>
    <constraint>Use Java 17 records for DTOs (RegisterRequest, LoginRequest, LoginResponse, TokenResponse) as per Story 1.5 pattern</constraint>
    <constraint>Apply Bean Validation annotations (@NotBlank, @Email, @Size, @StrongPassword) on DTO fields</constraint>
    <constraint>Password hashing: BCrypt with strength 12 (configure BCryptPasswordEncoder bean in SecurityConfig)</constraint>
    <constraint>Token storage: Store refresh tokens in database with user association. Implement token_blacklist table for logout functionality</constraint>
    <constraint>Flyway migrations: Create V6__create_token_blacklist_table.sql, V7__create_audit_logs_table.sql, V8__add_account_lockout_fields_to_users.sql</constraint>
    <constraint>Database naming: Use snake_case for columns (e.g., password_hash, created_at) via CamelCaseToUnderscoresNamingStrategy</constraint>
    <constraint>Rate limiting: Use Ehcache (from Story 1.3) to cache failed login attempts in LoginAttemptService. No Redis dependency.</constraint>
    <constraint>Exception handling: Add custom exceptions (AccountLockedException, InvalidTokenException) to GlobalExceptionHandler with proper HTTP status codes</constraint>
    <constraint>Security: JWT secret from environment variable ${jwt.secret} in application-dev.yml. Never hardcode secrets in code.</constraint>
    <constraint>Cookie configuration: HTTP-only, Secure, SameSite=Strict for refresh token cookies</constraint>
    <constraint>Audit logging: Log all authentication events (REGISTRATION, LOGIN_SUCCESS, LOGIN_FAILED, LOGOUT, TOKEN_REFRESH) with IP address, user agent, correlation ID</constraint>
    <constraint>No frontend API routes: All APIs in Spring Boot backend. Next.js is frontend-only per Architecture decision.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>POST /api/v1/auth/register</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/auth/register
Request Body: { email, password, firstName, lastName, role, phone? }
Response 201: { id, email, firstName, lastName, role, active, createdAt }
Response 400: Validation errors
Response 409: Email already exists</signature>
      <path>backend/src/main/java/com/ultrabms/controller/AuthController.java</path>
    </interface>
    <interface>
      <name>POST /api/v1/auth/login</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/auth/login
Request Body: { email, password }
Response 200: { accessToken, refreshToken, expiresIn, user: { id, email, firstName, lastName, role } }
Sets HTTP-only cookie: refreshToken
Response 401: Invalid credentials
Response 423: Account locked</signature>
      <path>backend/src/main/java/com/ultrabms/controller/AuthController.java</path>
    </interface>
    <interface>
      <name>POST /api/v1/auth/refresh</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/auth/refresh
Request: Refresh token from cookie or body
Response 200: { accessToken, expiresIn }
Response 401: Invalid/expired refresh token</signature>
      <path>backend/src/main/java/com/ultrabms/controller/AuthController.java</path>
    </interface>
    <interface>
      <name>POST /api/v1/auth/logout</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/auth/logout
Request: Authorization header with access token
Response 204: No Content
Clears refresh token cookie
Adds tokens to blacklist</signature>
      <path>backend/src/main/java/com/ultrabms/controller/AuthController.java</path>
    </interface>
    <interface>
      <name>UserRepository.findByEmail(String email)</name>
      <kind>Repository method</kind>
      <signature>Optional&lt;User&gt; findByEmail(String email)</signature>
      <path>backend/src/main/java/com/ultrabms/repository/UserRepository.java</path>
    </interface>
    <interface>
      <name>JwtTokenProvider</name>
      <kind>Utility class</kind>
      <signature>String generateAccessToken(User user)
String generateRefreshToken(User user)
boolean validateToken(String token)
UUID getUserIdFromToken(String token)
String getEmailFromToken(String token)</signature>
      <path>backend/src/main/java/com/ultrabms/security/JwtTokenProvider.java</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Use Spring Boot Test framework with JUnit 5. Unit tests for JwtTokenProvider, AuthService, LoginAttemptService, StrongPasswordValidator. Integration tests for AuthController with MockMvc. Test Spring Security configuration with authenticated/unauthenticated requests. Manual testing with Swagger UI (/swagger-ui.html) and curl commands. Playwright E2E tests for frontend authentication flow.
    </standards>

    <locations>
      <location>backend/src/test/java/com/ultrabms/security/</location>
      <location>backend/src/test/java/com/ultrabms/service/</location>
      <location>backend/src/test/java/com/ultrabms/controller/</location>
      <location>frontend/tests/ (Playwright E2E)</location>
    </locations>

    <ideas>
      <idea ac="AC1">Test registration with valid data → 201 Created. Test duplicate email → 409 Conflict. Test weak password → 400 Bad Request. Verify password hashed with BCrypt.</idea>
      <idea ac="AC2">Test password validation: weak password rejected, strong password accepted. Test StrongPasswordValidator with min 8 chars, uppercase, lowercase, digit, special char.</idea>
      <idea ac="AC3">Test login with valid credentials → 200 OK + JWT tokens. Test invalid credentials → 401 Unauthorized. Verify HTTP-only cookie set for refresh token.</idea>
      <idea ac="AC4">Test JwtTokenProvider: generateAccessToken, generateRefreshToken, validateToken, getUserIdFromToken. Verify token expiration (1 hour access, 7 days refresh). Test HS256 signing.</idea>
      <idea ac="AC5">Test rate limiting: 6 failed login attempts → account locked. Test account lockout for 30 minutes. Verify audit logs created with IP address and timestamp.</idea>
      <idea ac="AC6">Test token refresh with valid refresh token → 200 OK + new access token. Test with expired refresh token → 401 Unauthorized. Test with blacklisted token → 401.</idea>
      <idea ac="AC7">Test logout adds tokens to blacklist. Test blacklisted token cannot be used for authentication. Verify HTTP-only cookie cleared.</idea>
      <idea ac="All">E2E test: Register user → Login → Access protected endpoint → Refresh token → Logout → Verify token invalid. Test via Swagger UI and Playwright.</idea>
    </ideas>
  </tests>
</story-context>
