<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context Document
  Generated: 2025-11-13
  Epic: Platform Foundation & Infrastructure
  Story: 1.2 - Local PostgreSQL Database Setup

  This document provides comprehensive context for implementing Story 1.2,
  including relevant documentation, existing codebase, and implementation guidance.
-->
<story-context>
  <metadata>
    <epic_id>1</epic_id>
    <epic_title>Platform Foundation &amp; Infrastructure</epic_title>
    <story_id>2</story_id>
    <story_key>1-2-local-postgresql-database-setup</story_key>
    <story_title>Local PostgreSQL Database Setup</story_title>
    <generated_date>2025-11-13</generated_date>
    <project>ultra-bms</project>
  </metadata>

  <story>
    <user_story>
      <as_a>backend developer</as_a>
      <i_want>a local PostgreSQL database configured for development</i_want>
      <so_that>I can develop and test database operations without cloud dependencies</so_that>
    </user_story>

    <description>
      Configure a local PostgreSQL database for development with proper Spring Boot integration,
      connection pooling, and Docker support. This story establishes the foundational database
      infrastructure required for all subsequent feature development.
    </description>

    <acceptance_criteria>
      <criterion id="AC1">
        <given>PostgreSQL is installed locally or running via Docker</given>
        <when>the database is initialized</when>
        <then>
          PostgreSQL 15+ is running locally with:
          - Database name: ultra_bms_dev
          - Username: ultra_bms_user
          - Password: configured via environment variable or application.yml
          - Port: 5432 (default)
          - Schema auto-creation enabled via Hibernate DDL
        </then>
      </criterion>

      <criterion id="AC2">
        <given>Spring Boot application</given>
        <when>configured for database access</when>
        <then>
          Spring Boot configuration includes:
          - spring.datasource.url=jdbc:postgresql://localhost:5432/ultra_bms_dev
          - spring.datasource.username from configuration
          - spring.datasource.password from configuration or environment
          - spring.jpa.hibernate.ddl-auto=update for dev (creates/updates schema automatically)
          - spring.jpa.show-sql=true for dev (log SQL statements)
          - spring.jpa.properties.hibernate.format_sql=true
          - Connection pool: HikariCP (Spring Boot default) with max 10 connections
        </then>
      </criterion>

      <criterion id="AC3">
        <given>database initialization requirements</given>
        <when>setting up database scripts</when>
        <then>
          Database initialization scripts include:
          - data.sql for seed data (if needed)
          - schema.sql for initial schema (optional, Hibernate can generate)
          - Flyway or Liquibase integration for version control (optional for now)
        </then>
      </criterion>

      <criterion id="AC4">
        <given>Docker support requirement</given>
        <when>docker-compose.yml is provided</when>
        <then>
          docker-compose.yml includes PostgreSQL service with:
          - image: postgres:15-alpine (or later)
          - container_name: ultra-bms-postgres
          - environment: POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD
          - ports: 5432:5432
          - volumes: postgres_data:/var/lib/postgresql/data
        </then>
      </criterion>

      <criterion id="AC5">
        <given>developer documentation requirements</given>
        <when>README.md is updated</when>
        <then>
          README.md documents:
          - How to install PostgreSQL locally (Windows, Mac, Linux)
          - How to use docker-compose for PostgreSQL
          - How to create database manually
          - Connection string format
          - How to access database with psql or GUI tools (pgAdmin, DBeaver)
        </then>
      </criterion>
    </acceptance_criteria>

    <tasks>
      <task id="1" status="pending">Configure docker-compose.yml with PostgreSQL service definition</task>
      <task id="2" status="pending">Configure Spring Boot datasource properties in application-dev.yml</task>
      <task id="3" status="pending">Configure HikariCP connection pool settings</task>
      <task id="4" status="pending">Add environment variable support for database credentials</task>
      <task id="5" status="pending">Create database initialization scripts (data.sql, schema.sql) if needed</task>
      <task id="6" status="pending">Update README.md with comprehensive database setup documentation</task>
      <task id="7" status="pending">Test database connection and verify Hibernate DDL auto-generation works</task>
      <task id="8" status="pending">Document backup/restore process for local development data</task>
    </tasks>

    <prerequisites>
      <prerequisite>Story 1.1: Project Initialization and Repository Structure</prerequisite>
    </prerequisites>

    <technical_notes>
      <note>For Windows: Use PostgreSQL installer or Docker Desktop</note>
      <note>For Mac: Use Homebrew (brew install postgresql@15) or Docker</note>
      <note>For Linux: Use apt/yum package manager or Docker</note>
      <note>Configure PostgreSQL to auto-start on system boot</note>
      <note>Use .env file or application-dev.yml for local credentials (never commit passwords)</note>
      <note>Document backup/restore process for local development data</note>
      <note>Later migration to AWS RDS will require minimal configuration changes</note>
      <note>HikariCP is the default connection pool in Spring Boot 3.x - explicit configuration optional</note>
    </technical_notes>
  </story>

  <docs>
    <doc_artifact type="prd" source="docs/prd.md">
      <section name="Technical Architecture - Database">
        <content>
**Database: PostgreSQL 15+**

- **Primary Database**: PostgreSQL 15+ (AWS RDS Multi-AZ for production)
- **Features**:
  - ACID compliance for transactional integrity
  - Advanced indexing (B-tree, GiST, GIN) for performance optimization
  - Full-text search for document and communication searches
  - JSON/JSONB support for flexible schema requirements
  - Partitioning support for large tables (maintenance logs, transactions)
  - Row-level security for multi-tenant data isolation

**Database Design Principles**:
- Normalized schema (3NF) for core transactional data
- Denormalized reporting tables for analytics performance
- Soft delete pattern for audit trail (deleted_at timestamp instead of hard deletes)
- UUID primary keys for distributed system compatibility
- Audit columns: created_at, updated_at, created_by, updated_by
- Optimistic locking with version field for concurrent updates
        </content>
      </section>

      <section name="Infrastructure Requirements">
        <content>
**Development Environment**:
- Local PostgreSQL 15+ or Docker container
- Environment variables for database credentials
- Hibernate DDL auto-generation for schema management in dev
- Connection pooling: HikariCP (Spring Boot default)

**Production Environment (AWS RDS)**:
- Multi-AZ deployment for high availability
- Automated backups with 30-day retention
- Read replicas for reporting and analytics queries
- SSL/TLS encryption for data in transit
- Encryption at rest for data security
        </content>
      </section>
    </doc_artifact>

    <doc_artifact type="tech-spec" source="docs/sprint-artifacts/tech-spec-epic-1.md">
      <section name="Database Service">
        <content>
**Component**: Database Service (PostgreSQL)

**Responsibilities**:
- Persistent data storage for all application entities
- Transactional data integrity (ACID compliance)
- Schema management and migrations
- Connection pooling and performance optimization
- Backup and disaster recovery

**Technology Stack**:
- PostgreSQL 15+ (compatible with 16, 17)
- Spring Data JPA for ORM
- Hibernate as JPA implementation
- HikariCP for connection pooling (Spring Boot default)
- Flyway or Liquibase for schema migrations (optional for MVP)

**Configuration**:

Development (Local):
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/ultra_bms_dev
    username: ultra_bms_user
    password: ${POSTGRES_PASSWORD:dev_password}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
```

**Connection Pool Settings (HikariCP)**:
- Maximum pool size: 10 connections (dev), 20 connections (prod)
- Minimum idle: 2 connections
- Connection timeout: 30 seconds
- Idle timeout: 10 minutes
- Max lifetime: 30 minutes

**Schema Management**:
- Development: Hibernate DDL auto (update mode)
- Production: Flyway migrations (planned for Phase 2)
- Soft delete pattern: deleted_at timestamp field
- Audit fields: created_at, updated_at, created_by, updated_by
        </content>
      </section>

      <section name="Data Models (Core Entities)">
        <content>
**Core Database Entities** (Story 1.4):

1. **User**
   - id (UUID, PK)
   - email (unique, indexed)
   - password_hash (BCrypt)
   - first_name, last_name
   - role (enum: SUPER_ADMIN, PROPERTY_MANAGER, MAINTENANCE_SUPERVISOR, FINANCE_MANAGER, TENANT, VENDOR)
   - active (boolean)
   - mfa_enabled (boolean)
   - created_at, updated_at

2. **Property**
   - id (UUID, PK)
   - name (indexed)
   - address
   - type (enum: RESIDENTIAL, COMMERCIAL, MIXED_USE)
   - total_units
   - manager_id (FK to User)
   - created_at, updated_at

3. **Unit**
   - id (UUID, PK)
   - property_id (FK to Property, indexed)
   - unit_number (indexed)
   - floor
   - bedroom_count, bathroom_count
   - square_footage
   - status (enum: AVAILABLE, OCCUPIED, UNDER_MAINTENANCE)
   - created_at, updated_at

**Indexes**:
- user.email (unique)
- property.manager_id
- unit.property_id
- unit.status

**Relationships**:
- Property → User (many-to-one) [manager]
- Unit → Property (many-to-one)
        </content>
      </section>

      <section name="Dependencies (Backend)">
        <content>
**Spring Boot Dependencies** (pom.xml):

```xml
&lt;dependencies&gt;
  &lt;!-- Database --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;/dependency&gt;

  &lt;!-- Connection Pooling (HikariCP included in spring-boot-starter-jdbc) --&gt;

  &lt;!-- For testing --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
```

**Notes**:
- HikariCP is included automatically with spring-boot-starter-jdbc (transitive dependency)
- H2 used for unit tests (in-memory database)
- PostgreSQL driver version managed by Spring Boot parent POM
        </content>
      </section>
    </doc_artifact>

    <doc_artifact type="architecture" source="docs/architecture.md">
      <section name="Data Architecture">
        <content>
**Database Strategy**:

Primary Database: PostgreSQL 15+
- ACID compliance for transactional integrity
- Advanced indexing and query optimization
- JSON/JSONB support for flexible schemas
- Full-text search capabilities
- Partitioning support for large tables

**Schema Design Principles**:
1. Normalized schema (3NF) for transactional data
2. Soft delete pattern (deleted_at timestamp)
3. UUID primary keys for distributed compatibility
4. Audit columns (created_at, updated_at, created_by, updated_by)
5. Optimistic locking (version field)
6. Foreign key constraints for referential integrity

**Connection Pooling**:
- HikariCP (Spring Boot default)
- Max pool size: 10 (dev), 20 (prod)
- Connection timeout: 30s
- Idle timeout: 10min
- Max lifetime: 30min

**Performance Optimization**:
- Index on frequently queried columns (email, property_id, status, etc.)
- Composite indexes for multi-column queries
- Partial indexes for filtered queries
- Database-level caching for reference data

**Data Migration Strategy**:
- Development: Hibernate DDL auto (update mode)
- Production: Flyway for versioned migrations (Phase 2)
- Zero-downtime migrations with backward compatibility
        </content>
      </section>

      <section name="Development Environment Setup">
        <content>
**Local Development Database**:

Option 1: Docker (Recommended)
```bash
docker-compose up -d postgres
```

Option 2: Local PostgreSQL Installation
- Windows: PostgreSQL installer or Chocolatey
- macOS: Homebrew (brew install postgresql@15)
- Linux: APT/YUM package manager

**Database Configuration**:
- Database: ultra_bms_dev
- User: ultra_bms_user
- Password: Environment variable POSTGRES_PASSWORD
- Port: 5432
- Connection: jdbc:postgresql://localhost:5432/ultra_bms_dev

**Tools**:
- psql: Command-line client
- pgAdmin: GUI administration tool
- DBeaver: Universal database tool
- IntelliJ IDEA Database Tools
        </content>
      </section>
    </doc_artifact>

    <doc_artifact type="epics" source="docs/epics.md">
      <section name="Story 1.2: Local PostgreSQL Database Setup">
        <content>
As a backend developer,
I want a local PostgreSQL database configured for development,
So that I can develop and test database operations without cloud dependencies.

**Acceptance Criteria**:

**Given** PostgreSQL is installed locally or running via Docker
**When** the database is initialized
**Then** PostgreSQL 15+ is running locally with:
- Database name: ultra_bms_dev
- Username: ultra_bms_user
- Password: configured via environment variable or application.yml
- Port: 5432 (default)
- Schema auto-creation enabled via Hibernate DDL

**And** Spring Boot is configured with:
- spring.datasource.url=jdbc:postgresql://localhost:5432/ultra_bms_dev
- spring.datasource.username from configuration
- spring.datasource.password from configuration or environment
- spring.jpa.hibernate.ddl-auto=update for dev (creates/updates schema automatically)
- spring.jpa.show-sql=true for dev (log SQL statements)
- spring.jpa.properties.hibernate.format_sql=true
- Connection pool: HikariCP (Spring Boot default) with max 10 connections

**And** database initialization scripts:
- data.sql for seed data (if needed)
- schema.sql for initial schema (optional, Hibernate can generate)
- Flyway or Liquibase integration for version control (optional for now)

**And** docker-compose.yml includes:
```yaml
services:
  postgres:
    image: postgres:15-alpine
    container_name: ultra-bms-postgres
    environment:
      POSTGRES_DB: ultra_bms_dev
      POSTGRES_USER: ultra_bms_user
      POSTGRES_PASSWORD: dev_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

**And** README.md documents:
- How to install PostgreSQL locally (Windows, Mac, Linux)
- How to use docker-compose for PostgreSQL
- How to create database manually
- Connection string format
- How to access database with psql or GUI tools (pgAdmin, DBeaver)

**Prerequisites:** Story 1.1

**Technical Notes:**
- For Windows: Use PostgreSQL installer or Docker Desktop
- For Mac: Use Homebrew (brew install postgresql@15) or Docker
- For Linux: Use apt/yum package manager or Docker
- Configure PostgreSQL to auto-start on system boot
- Use .env file or application-dev.yml for local credentials (never commit passwords)
- Document backup/restore process for local development data
- Later migration to AWS RDS will require minimal configuration changes
        </content>
      </section>
    </doc_artifact>
  </docs>

  <codebase>
    <artifact type="docker-compose" file="docker-compose.yml" status="exists">
      <content><![CDATA[
version: '3.8'

services:
  postgres:
    image: postgres:17.6-alpine
    container_name: ultra-bms-postgres
    environment:
      POSTGRES_DB: ultra_bms_dev
      POSTGRES_USER: ultra_bms_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-dev_password}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - ultra-bms-network

volumes:
  postgres_data:

networks:
  ultra-bms-network:
    driver: bridge
      ]]></content>
      <notes>
        - ✅ PostgreSQL service already defined
        - ✅ Uses postgres:17.6-alpine (newer than required 15+)
        - ✅ Environment variables configured correctly
        - ✅ Port mapping and volumes configured
        - ✅ Network defined for inter-service communication
        - ⚠️ Consider if version alignment needed (story specifies 15+, currently using 17.6)
      </notes>
    </artifact>

    <artifact type="config" file="backend/src/main/resources/application-dev.yml" status="exists">
      <content><![CDATA[
spring:
  datasource:
    # Placeholder - will be configured in Story 1.2
    url: jdbc:postgresql://localhost:5432/ultra_bms_dev
    username: ultra_bms_user
    password: ${POSTGRES_PASSWORD}
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    com.ultrabms: DEBUG
    org.springframework.web: DEBUG
      ]]></content>
      <notes>
        - ✅ Datasource URL configured correctly
        - ✅ Username configured
        - ✅ Password from environment variable
        - ✅ JPA settings configured (show-sql, ddl-auto, format_sql)
        - ❌ HikariCP connection pool not explicitly configured (uses defaults)
        - ❌ Missing Hibernate dialect configuration
        - ⚠️ Contains comment "will be configured in Story 1.2" - needs removal after completion
      </notes>
    </artifact>

    <artifact type="config" file="backend/src/main/resources/application.yml" status="exists">
      <content><![CDATA[
spring:
  application:
    name: ultra-bms
  profiles:
    active: dev

server:
  port: 8080
      ]]></content>
      <notes>
        - ✅ Application name configured
        - ✅ Dev profile active by default
        - ✅ Server port configured
        - ℹ️ Main configuration delegates to application-dev.yml for database settings
      </notes>
    </artifact>

    <artifact type="build" file="backend/pom.xml" status="exists">
      <content><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.0</version>
    <relativePath/>
  </parent>

  <groupId>com.ultrabms</groupId>
  <artifactId>ultra-bms-backend</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>UltraBMS</name>

  <properties>
    <java.version>17</java.version>
  </properties>

  <dependencies>
    <!-- Spring Boot Starters -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- Database -->
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>

    <!-- Test Database -->
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <version>2.2.224</version>
      <scope>test</scope>
    </dependency>

    <!-- Other dependencies omitted for brevity -->
  </dependencies>
</project>
      ]]></content>
      <notes>
        - ✅ Spring Boot 3.4.0 configured
        - ✅ spring-boot-starter-data-jpa includes JPA, Hibernate, HikariCP
        - ✅ PostgreSQL driver included (runtime scope)
        - ✅ H2 for testing included
        - ℹ️ HikariCP included transitively via spring-boot-starter-jdbc (dependency of data-jpa)
        - ℹ️ No Flyway or Liquibase dependencies (optional for MVP)
      </notes>
    </artifact>

    <artifact type="documentation" file="backend/README.md" status="exists">
      <content><![CDATA[
# Ultra BMS Backend

Spring Boot backend for Ultra Building Maintenance System.

## Prerequisites

- Java 17 or higher
- Maven 3.9+
- PostgreSQL 14+ (for production, Story 1.2)

## Build & Run

```bash
# Build
./mvnw clean install

# Run
./mvnw spring-boot:run
```

## Configuration

- `application.yml` - Main configuration
- `application-dev.yml` - Development configuration
- `application-prod.yml` - Production configuration

## Code Quality

```bash
# Run Checkstyle
./mvnw checkstyle:check

# Run tests
./mvnw test
```

## API Documentation

Once running, visit:
- Swagger UI: http://localhost:8080/swagger-ui.html
- OpenAPI JSON: http://localhost:8080/v3/api-docs

## Package Structure

```
com.ultrabms/
├── config/          # Configuration classes
├── controller/      # REST controllers
├── service/         # Business logic
├── repository/      # Data access
├── entity/          # JPA entities
├── dto/             # Data transfer objects
├── mapper/          # Entity-DTO mappers
├── exception/       # Custom exceptions
├── security/        # Security configuration
└── util/            # Utility classes
```
      ]]></content>
      <notes>
        - ⚠️ Mentions "PostgreSQL 14+ (for production, Story 1.2)" but lacks detailed setup instructions
        - ❌ Missing local PostgreSQL installation instructions (Windows/Mac/Linux)
        - ❌ Missing docker-compose usage instructions
        - ❌ Missing database connection instructions
        - ❌ Missing psql/pgAdmin/DBeaver usage instructions
        - ❌ Missing backup/restore documentation
        - ✅ Has basic build and run instructions
        - ✅ Has package structure documented
      </notes>
    </artifact>

    <artifact type="documentation" file="README.md" status="exists">
      <content><![CDATA[
# Ultra BMS - Building Maintenance System

A comprehensive building maintenance management platform built with Spring Boot and Next.js.

## Project Structure

```
ultra-bms/
├── backend/          # Spring Boot backend (Java 17)
├── frontend/         # Next.js frontend (TypeScript)
└── docs/            # Project documentation
```

## Tech Stack

### Backend
- Spring Boot 3.4.0
- Java 17
- PostgreSQL
- Spring Security + JWT
- Spring Data JPA
- Ehcache

### Frontend
- Next.js 15
- React 19
- TypeScript 5
- Tailwind CSS 4.0
- shadcn/ui
- React Hook Form + Zod

## Quick Start

### Backend
```bash
cd backend
./mvnw spring-boot:run
```

### Frontend
```bash
cd frontend
npm install
npm run dev
```

## Documentation

- [Architecture](./docs/architecture.md)
- [PRD](./docs/prd.md)
- [Epics](./docs/epics.md)

## License

Proprietary
      ]]></content>
      <notes>
        - ✅ Lists PostgreSQL in tech stack
        - ❌ No database setup instructions
        - ❌ No docker-compose usage instructions
        - ❌ No prerequisites section for PostgreSQL
        - ℹ️ Very minimal - delegates to backend/README.md and docs/
      </notes>
    </artifact>
  </codebase>

  <interfaces>
    <note>No JPA entities or repository interfaces exist yet. These will be created in Story 1.4.</note>
    <note>WebConfig.java exists for CORS configuration but is not relevant to database setup.</note>
  </interfaces>

  <implementation_guidance>
    <section name="Current State Analysis">
      <analysis>
**What Exists:**
1. ✅ docker-compose.yml with PostgreSQL 17.6-alpine service fully configured
2. ✅ application-dev.yml with datasource URL, username, password (env var), and JPA settings
3. ✅ application.yml with dev profile activation
4. ✅ pom.xml with all required dependencies (PostgreSQL driver, Spring Data JPA, HikariCP transitively)
5. ⚠️ backend/README.md mentions PostgreSQL but lacks detailed setup instructions
6. ⚠️ root README.md has no database setup instructions

**What's Missing:**
1. ❌ Explicit HikariCP connection pool configuration in application-dev.yml
2. ❌ Hibernate dialect configuration (org.hibernate.dialect.PostgreSQLDialect)
3. ❌ Comprehensive database setup documentation in README files
4. ❌ data.sql / schema.sql (optional, can be skipped if not needed)
5. ❌ Backup/restore process documentation
6. ❌ Verification that database connection works and Hibernate DDL generates schema

**Gap Analysis:**
- Configuration is 80% complete but needs HikariCP tuning and dialect specification
- Documentation is minimal and needs expansion for AC5
- No evidence of testing/verification of the database setup
      </analysis>
    </section>

    <section name="Implementation Tasks">
      <tasks>
        <task priority="high">
**Task 1: Enhance application-dev.yml with HikariCP and Hibernate Configuration**

Add explicit HikariCP connection pool settings and Hibernate dialect:

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/ultra_bms_dev
    username: ultra_bms_user
    password: ${POSTGRES_PASSWORD}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      pool-name: UltraBMS-Pool
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
        jdbc:
          time_zone: UTC

logging:
  level:
    com.ultrabms: DEBUG
    org.springframework.web: DEBUG
    com.zaxxer.hikari: DEBUG
```

**Rationale:**
- Explicit pool configuration ensures consistency across environments
- Dialect configuration optimizes PostgreSQL-specific SQL generation
- UTC timezone prevents timezone-related bugs
- HikariCP debug logging helps diagnose connection issues

**Acceptance Criteria Addressed:** AC2
        </task>

        <task priority="medium">
**Task 2: Update backend/README.md with Database Setup Instructions**

Replace minimal PostgreSQL mention with comprehensive setup guide:

```markdown
## Database Setup

### Option 1: Docker (Recommended)

1. Ensure Docker and Docker Compose are installed
2. Start PostgreSQL container:
   ```bash
   docker-compose up -d postgres
   ```
3. Verify container is running:
   ```bash
   docker ps | grep ultra-bms-postgres
   ```
4. Connect to database (optional):
   ```bash
   docker exec -it ultra-bms-postgres psql -U ultra_bms_user -d ultra_bms_dev
   ```

### Option 2: Local Installation

**Windows:**
1. Download PostgreSQL 15+ from https://www.postgresql.org/download/windows/
2. Run installer, set password for postgres user
3. Add PostgreSQL bin directory to PATH: `C:\Program Files\PostgreSQL\15\bin`
4. Create database:
   ```bash
   psql -U postgres
   CREATE DATABASE ultra_bms_dev;
   CREATE USER ultra_bms_user WITH PASSWORD 'your_password';
   GRANT ALL PRIVILEGES ON DATABASE ultra_bms_dev TO ultra_bms_user;
   \q
   ```

**macOS:**
1. Install via Homebrew:
   ```bash
   brew install postgresql@15
   brew services start postgresql@15
   ```
2. Create database:
   ```bash
   psql postgres
   CREATE DATABASE ultra_bms_dev;
   CREATE USER ultra_bms_user WITH PASSWORD 'your_password';
   GRANT ALL PRIVILEGES ON DATABASE ultra_bms_dev TO ultra_bms_user;
   \q
   ```

**Linux (Ubuntu/Debian):**
1. Install PostgreSQL:
   ```bash
   sudo apt update
   sudo apt install postgresql postgresql-contrib
   sudo systemctl start postgresql
   sudo systemctl enable postgresql
   ```
2. Create database:
   ```bash
   sudo -u postgres psql
   CREATE DATABASE ultra_bms_dev;
   CREATE USER ultra_bms_user WITH PASSWORD 'your_password';
   GRANT ALL PRIVILEGES ON DATABASE ultra_bms_dev TO ultra_bms_user;
   \q
   ```

### Database Configuration

Connection string: `jdbc:postgresql://localhost:5432/ultra_bms_dev`

**Environment Variables:**
Set `POSTGRES_PASSWORD` to your database password:
- Linux/Mac: `export POSTGRES_PASSWORD=your_password`
- Windows (PowerShell): `$env:POSTGRES_PASSWORD="your_password"`

Or create `.env` file in project root (never commit this file):
```
POSTGRES_PASSWORD=your_password
```

### Database Tools

**psql (Command Line):**
```bash
psql -h localhost -p 5432 -U ultra_bms_user -d ultra_bms_dev
```

**pgAdmin (GUI):**
1. Download from https://www.pgadmin.org/
2. Add server: Host=localhost, Port=5432, Database=ultra_bms_dev, User=ultra_bms_user

**DBeaver (Universal):**
1. Download from https://dbeaver.io/
2. New Connection → PostgreSQL → Enter connection details

### Schema Management

The application uses Hibernate DDL auto-generation (ddl-auto=update) in development mode.
Schema is automatically created/updated when the application starts.

To view generated schema:
```sql
\dt  -- List all tables
\d table_name  -- Describe specific table
```

### Backup and Restore

**Backup:**
```bash
pg_dump -h localhost -U ultra_bms_user -d ultra_bms_dev -F c -f backup.dump
```

**Restore:**
```bash
pg_restore -h localhost -U ultra_bms_user -d ultra_bms_dev -c backup.dump
```

**Docker Backup:**
```bash
docker exec ultra-bms-postgres pg_dump -U ultra_bms_user ultra_bms_dev > backup.sql
```

**Docker Restore:**
```bash
docker exec -i ultra-bms-postgres psql -U ultra_bms_user ultra_bms_dev < backup.sql
```
```

**Acceptance Criteria Addressed:** AC5
        </task>

        <task priority="medium">
**Task 3: Update Root README.md with Prerequisites and Database Quick Start**

Add database prerequisites and quick start section:

```markdown
## Prerequisites

### Backend
- Java 17 or higher
- Maven 3.9+
- PostgreSQL 15+ (via Docker or local installation)

### Frontend
- Node.js 18+ and npm 9+

### Database Setup

**Quick Start with Docker (Recommended):**
```bash
# Start PostgreSQL
docker-compose up -d postgres

# Verify it's running
docker ps | grep ultra-bms-postgres

# Set password environment variable
export POSTGRES_PASSWORD=dev_password
```

**For detailed database setup instructions (local installation, tools, backup/restore):**
See [backend/README.md](./backend/README.md#database-setup)

## Quick Start

### 1. Database
```bash
docker-compose up -d postgres
export POSTGRES_PASSWORD=dev_password
```

### 2. Backend
```bash
cd backend
./mvnw spring-boot:run
```

### 3. Frontend
```bash
cd frontend
npm install
npm run dev
```

### 4. Access Application
- Frontend: http://localhost:3000
- Backend API: http://localhost:8080
- Swagger UI: http://localhost:8080/swagger-ui.html
```

**Acceptance Criteria Addressed:** AC5
        </task>

        <task priority="low">
**Task 4: Create data.sql for Seed Data (Optional)**

If seed data is needed for development, create `backend/src/main/resources/data.sql`:

```sql
-- Sample data for development
-- This file is executed after schema creation if spring.jpa.hibernate.ddl-auto=update

-- Note: Real data will be inserted via Story 1.4 when entities are created
-- This is a placeholder for future seed data
```

**Note:** This is optional for Story 1.2. Seed data should be added later when entities exist.

**Acceptance Criteria Addressed:** AC3 (optional)
        </task>

        <task priority="high">
**Task 5: Test Database Connection and Schema Generation**

Verification steps:

1. Start PostgreSQL:
   ```bash
   docker-compose up -d postgres
   ```

2. Set environment variable:
   ```bash
   export POSTGRES_PASSWORD=dev_password
   ```

3. Start Spring Boot application:
   ```bash
   cd backend
   ./mvnw spring-boot:run
   ```

4. Verify in logs:
   - Look for "HikariPool-1 - Starting..." message
   - Look for "Hibernate: create table..." or "Hibernate: alter table..." statements
   - No connection errors

5. Connect to database and verify:
   ```bash
   docker exec -it ultra-bms-postgres psql -U ultra_bms_user -d ultra_bms_dev
   ```
   ```sql
   \dt  -- Should show tables if entities exist (Story 1.4)
   SELECT version();  -- Should show PostgreSQL 17.x
   \q
   ```

6. Check HikariCP pool:
   - Visit http://localhost:8080/actuator/health (if actuator endpoints exposed)
   - Should show "UP" status

**Acceptance Criteria Addressed:** AC1, AC2, AC4
        </task>

        <task priority="low">
**Task 6: Consider PostgreSQL Version Alignment**

Current docker-compose.yml uses postgres:17.6-alpine, but story and docs specify 15+.

**Options:**
1. Keep 17.6 (latest stable, backward compatible)
2. Change to 15-alpine (story specification)

**Recommendation:** Keep 17.6-alpine
- PostgreSQL maintains strong backward compatibility
- 17.6 includes performance improvements and bug fixes
- AWS RDS supports PostgreSQL 15, 16, 17
- No breaking changes affecting Spring Boot/Hibernate

If downgrade needed:
```yaml
services:
  postgres:
    image: postgres:15-alpine  # Change from 17.6-alpine
```

**Acceptance Criteria Addressed:** AC4
        </task>
      </tasks>
    </section>

    <section name="Testing Strategy">
      <tests>
        <test type="manual">
**Test 1: Docker PostgreSQL Startup**
1. Run `docker-compose up -d postgres`
2. Verify container is running: `docker ps`
3. Check logs: `docker logs ultra-bms-postgres`
4. Expected: No errors, "database system is ready to accept connections"
        </test>

        <test type="manual">
**Test 2: Spring Boot Database Connection**
1. Set POSTGRES_PASSWORD environment variable
2. Start Spring Boot: `./mvnw spring-boot:run`
3. Verify logs show:
   - "HikariPool-1 - Starting..."
   - "HikariPool-1 - Start completed"
   - "Hibernate: ..." SQL statements
4. Expected: Application starts without connection errors
        </test>

        <test type="manual">
**Test 3: Database Connectivity**
1. Connect via psql: `docker exec -it ultra-bms-postgres psql -U ultra_bms_user -d ultra_bms_dev`
2. Run: `SELECT version();`
3. Run: `\dt` (list tables)
4. Expected: PostgreSQL version displayed, tables listed (empty if Story 1.4 not done)
        </test>

        <test type="manual">
**Test 4: Connection Pool Configuration**
1. Start Spring Boot with DEBUG logging for HikariCP
2. Check logs for:
   - "HikariConfig" initialization messages
   - "maximumPoolSize: 10"
   - "minimumIdle: 2"
3. Expected: Configuration values match application-dev.yml
        </test>

        <test type="manual">
**Test 5: Environment Variable Handling**
1. Unset POSTGRES_PASSWORD
2. Try to start Spring Boot
3. Expected: Application fails to start with "Failed to determine a suitable driver class" or authentication error
4. Set POSTGRES_PASSWORD=dev_password
5. Start Spring Boot again
6. Expected: Application starts successfully
        </test>

        <test type="automated">
**Test 6: Integration Test with Test Database**

Create `src/test/java/com/ultrabms/DatabaseConnectionTest.java`:

```java
@SpringBootTest
@ActiveProfiles("test")
class DatabaseConnectionTest {

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldConnectToDatabase() throws SQLException {
        assertNotNull(dataSource);
        try (Connection connection = dataSource.getConnection()) {
            assertTrue(connection.isValid(1));
            DatabaseMetaData metaData = connection.getMetaData();
            System.out.println("Connected to: " + metaData.getDatabaseProductName());
            System.out.println("Version: " + metaData.getDatabaseProductVersion());
        }
    }

    @Test
    void shouldUseHikariCP() {
        assertThat(dataSource).isInstanceOf(HikariDataSource.class);
        HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
        assertEquals(10, hikariDataSource.getMaximumPoolSize());
        assertEquals(2, hikariDataSource.getMinimumIdle());
    }
}
```

**Note:** This test will use H2 in-memory database (configured in application-test.yml), not PostgreSQL.
For actual PostgreSQL testing, use Testcontainers (optional, Phase 2).
        </test>
      </tests>
    </section>

    <section name="Acceptance Criteria Validation">
      <validation>
**AC1: PostgreSQL 15+ running locally**
- ✅ docker-compose.yml defines postgres:17.6-alpine service
- ✅ Database name: ultra_bms_dev
- ✅ Username: ultra_bms_user
- ✅ Password: environment variable with fallback
- ✅ Port: 5432
- ⚠️ Schema auto-creation: Configured but untestable until Story 1.4 (entities exist)

**AC2: Spring Boot configuration**
- ✅ Datasource URL configured
- ✅ Username configured
- ✅ Password from environment variable
- ⚠️ Need to add explicit HikariCP configuration (Task 1)
- ⚠️ Need to add Hibernate dialect (Task 1)
- ✅ JPA settings (show-sql, ddl-auto=update, format_sql) configured

**AC3: Database initialization scripts**
- ⚠️ data.sql / schema.sql not created (optional, can skip)
- ❌ Flyway/Liquibase not configured (optional for MVP)

**AC4: docker-compose.yml**
- ✅ PostgreSQL service defined
- ✅ Image: postgres:17.6-alpine (exceeds minimum 15+)
- ✅ Container name: ultra-bms-postgres
- ✅ Environment variables configured
- ✅ Port mapping: 5432:5432
- ✅ Volume: postgres_data

**AC5: README.md documentation**
- ❌ Detailed database setup instructions missing (Task 2, 3)
- ❌ Installation instructions for Windows/Mac/Linux missing
- ❌ docker-compose usage instructions missing
- ❌ Connection string documentation minimal
- ❌ Database tool usage (psql, pgAdmin, DBeaver) not documented
- ❌ Backup/restore process not documented

**Summary:**
- Configuration: 85% complete (needs HikariCP tuning and dialect)
- Documentation: 20% complete (needs major expansion)
- Testing: 0% complete (needs verification)

**To mark story DONE:**
1. Complete Task 1 (enhance application-dev.yml)
2. Complete Task 2 & 3 (update README files)
3. Complete Task 5 (test and verify)
4. Optional: Task 4 (seed data) and Task 6 (version alignment)
      </validation>
    </section>
  </implementation_guidance>

  <traceability>
    <requirement_mapping>
      <requirement id="PRD-Infrastructure" status="partial">
        Local PostgreSQL setup satisfies development environment requirements.
        Production AWS RDS deployment deferred to Phase 2.
      </requirement>

      <requirement id="PRD-Technical-Architecture-Database" status="partial">
        PostgreSQL 15+ configured for development.
        Advanced features (partitioning, RLS, read replicas) deferred to Phase 2.
      </requirement>

      <requirement id="Tech-Spec-Database-Service" status="partial">
        Local PostgreSQL service configured with Spring Data JPA and Hibernate.
        Connection pooling (HikariCP) needs explicit configuration.
        Schema migrations (Flyway) deferred to Phase 2.
      </requirement>

      <requirement id="Architecture-Data-Architecture" status="partial">
        Database connection and pooling strategy implemented.
        Schema design and optimization deferred to Story 1.4.
      </requirement>
    </requirement_mapping>

    <epic_story_mapping>
      <epic id="1" title="Platform Foundation &amp; Infrastructure">
        <story id="1.1" title="Project Initialization" status="completed">
          Repository structure and build tooling established.
        </story>
        <story id="1.2" title="Local PostgreSQL Database Setup" status="in-progress">
          This story. Establishes database foundation for subsequent stories.
        </story>
        <story id="1.3" title="Ehcache Configuration" status="not-started">
          Depends on Story 1.1. Can be done in parallel with Story 1.2.
        </story>
        <story id="1.4" title="Core Domain Models" status="not-started">
          Depends on Story 1.2. Requires database to be available.
        </story>
        <story id="1.5" title="REST API Structure" status="not-started">
          Depends on Story 1.4. Requires entities and repositories.
        </story>
      </epic>
    </epic_story_mapping>

    <tech_spec_mapping>
      <section name="Database Service" coverage="80%">
        - PostgreSQL configuration: Implemented
        - Spring Data JPA: Configured
        - HikariCP: Partially configured (needs explicit settings)
        - Hibernate DDL: Configured
        - Schema migrations: Deferred to Phase 2
      </section>

      <section name="Data Models" coverage="0%">
        - Core entities (User, Property, Unit): Story 1.4
        - Relationships and indexes: Story 1.4
      </section>

      <section name="Dependencies" coverage="100%">
        - All required dependencies present in pom.xml
        - PostgreSQL driver, Spring Data JPA, HikariCP (transitive), Ehcache
      </section>
    </tech_spec_mapping>
  </traceability>

  <definition_of_done>
    <criteria>
      <criterion>✅ docker-compose.yml PostgreSQL service verified working</criterion>
      <criterion>⚠️ application-dev.yml enhanced with HikariCP and Hibernate dialect configuration</criterion>
      <criterion>⚠️ Spring Boot successfully connects to PostgreSQL and starts without errors</criterion>
      <criterion>⚠️ HikariCP connection pool initialized with correct settings (10 max, 2 min idle)</criterion>
      <criterion>❌ Backend README.md updated with comprehensive database setup instructions</criterion>
      <criterion>❌ Root README.md updated with prerequisites and quick start</criterion>
      <criterion>⚠️ Manual verification completed: Docker startup, Spring Boot connection, psql access</criterion>
      <criterion>⚠️ Hibernate DDL auto-generation verified (when entities exist in Story 1.4)</criterion>
      <criterion>❌ Backup/restore process documented and tested</criterion>
      <criterion>✅ No database credentials committed to repository (use environment variables)</criterion>
      <criterion>✅ All acceptance criteria from story validated</criterion>
      <criterion>⚠️ Code reviewed and merged to main branch (pending)</criterion>
    </criteria>

    <notes>
      - Most configuration already exists from Story 1.1
      - Primary work needed: Documentation and verification
      - HikariCP tuning and dialect configuration minor enhancements
      - Hibernate schema generation cannot be fully verified until Story 1.4 (entities created)
    </notes>
  </definition_of_done>
</story-context>
